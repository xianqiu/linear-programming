<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linear Programming in Practice</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Linear Programming in Practice</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 27 Mar 2025 13:58:44 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基础算法</title>
      <link>//localhost:1313/docs/simplex-algorithm/implement/simplex-basic/</link>
      <pubDate>Thu, 27 Mar 2025 13:55:12 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/implement/simplex-basic/</guid>
      <description></description>
    </item>
    <item>
      <title>标准形式</title>
      <link>//localhost:1313/docs/basics/standard-form/</link>
      <pubDate>Fri, 21 Mar 2025 19:38:06 +0800</pubDate>
      <guid>//localhost:1313/docs/basics/standard-form/</guid>
      <description>&lt;p&gt;考虑一个线性规划的例子。&lt;/p&gt;&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;\begin{aligned}&#xA;\max~ &amp;amp; 7x_1 &amp;#43; 6 x_2\\&#xA;\text{s.t.}~ &amp;amp; 3x_1 &amp;#43; x_2 \leq 120 \\&#xA;&amp;amp; x_1 &amp;#43; 2x_2 \leq 160 \\&#xA;&amp;amp; x_1 \leq 35 \\&#xA;\end{aligned}&#xA;$$&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其中第一行是目标函数，其中 &lt;code&gt;max&lt;/code&gt;​ 代表优化方向，即最大化目标函数值。接下来是三个约束条件，分别用不等式来描述，其中 &lt;code&gt;s.t.&lt;/code&gt; 是 &lt;code&gt;subject to&lt;/code&gt; 的缩写）。&lt;/p&gt;&#xA;&lt;p&gt;求解这个问题，就要找到满足约束条件的 $x_1,x_2$，使得目标函数值最大。&lt;/p&gt;&#xA;&lt;h3 id=&#34;矩阵形式&#34;&gt;矩阵形式 &lt;a href=&#34;#%e7%9f%a9%e9%98%b5%e5%bd%a2%e5%bc%8f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;接下来我们把它写成矩阵的形式。定义列向量 $c$ 和 $x$:&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;c = \begin{bmatrix}&#xA;7\\&#xA;6&#xA;\end{bmatrix}\quad&#xA;x = \begin{bmatrix}&#xA;x_1\\&#xA;x_2&#xA;\end{bmatrix}&#xA;$$&#xA;  &lt;/div&gt;&#xA;那么目标函数可以写成 $c^Tx$。&#xA;定义矩阵 $A$ 和 列向量 $b$:&lt;/p&gt;</description>
    </item>
    <item>
      <title>单纯形算法</title>
      <link>//localhost:1313/docs/simplex-algorithm/simplex/</link>
      <pubDate>Fri, 21 Mar 2025 19:35:16 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/simplex/</guid>
      <description>&lt;p&gt;考虑线性规划问题的标准形式。&lt;/p&gt;&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;\begin{aligned}&#xA;\min~ &amp;amp; c^T x\\ &#xA;\text{s.t.}~ &amp;amp; Ax=b\\&#xA;&amp;amp; x\geq 0&#xA;\end{aligned}&#xA;$$&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其中 $c, x \in \mathbb{R}^n$，$A\in\mathbb{R}^{m\times n}$，$b\in\mathbb{R}^m \geq \mathbf{0}$，$n\geq m$。&lt;/p&gt;&#xA;&lt;p&gt;这个问题还可以这样描述。&lt;/p&gt;&#xA;&lt;p&gt;找到一个点 $x\in P:={\{x| Ax=b, x\geq 0\}}$，使得目标函数 $f(x):=c^Tx$ 最小化。从几何的角度来看，$P$ 是一个多面体，$x$ 是多面体的一个顶点。&lt;/p&gt;&#xA;&lt;p&gt;单纯形算法的思路就是，从多面体的某一个顶点开始，然后沿着目标函数减少的方向，迭代到另一个顶点，直到目标函数值无法降低。那么对应的顶点就是最优解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分块矩阵&#34;&gt;分块矩阵 &lt;a href=&#34;#%e5%88%86%e5%9d%97%e7%9f%a9%e9%98%b5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;先把原问题中的矩阵和向量用分块的方式表达。令 $B$ 和 $N$ 分别代表基矩阵和非基矩阵。$A$ 可以写成下面的形式。&lt;/p&gt;&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;A = [B \quad N]&#xA;$$&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;相应地，$x$ 和 $c$ 可以写成&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;x = \begin{bmatrix}&#xA;x_B \\&#xA;x_N&#xA;\end{bmatrix}\quad&#xA;c = \begin{bmatrix} c_B \\&#xA;c_N\end{bmatrix}&#xA;$$&#xA;  &lt;/div&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>为什么写这个教程</title>
      <link>//localhost:1313/docs/start/why/</link>
      <pubDate>Thu, 20 Mar 2025 20:00:22 +0800</pubDate>
      <guid>//localhost:1313/docs/start/why/</guid>
      <description>&lt;p&gt;线性规划是一门应用课程。它是数学系课程中，少有的实用性高的课程。我看过的一些资料，主要还是在讲理论，讲实践的比较少。比如说单纯形算法，我学过它的证明，了解它的算法细节。那问题来了，如果我想实现一个单纯形算法的求解器，应该怎么开始呢。从理论到工程，要解决哪些问题呢。&lt;/p&gt;&#xA;&lt;p&gt;如果你是计算机背景，这个难不到你。如果是数学背景，可能会遇到一些困难。但是线性规划的教材，一般不讲编程实现。在我看来，既然在讲算法，为什么不去实现呢。自己的代码跑起来，顺便做一些测试，这样也更容易理解算法。&lt;/p&gt;&#xA;&lt;p&gt;我之前在CSDN上写过一些基础的教程，文章的阅读量和收藏也不错。但我自己觉得写得不好，有些东西没讲清楚，代码质量也不高，但是我懒得在CSDN上改了。这个平台我不喜欢，写作体验不好，阅读体验也不好。平台还未经允许把我的文章转成了收费。当然，也没给我钱。我想把些之前写的内容做个整合，顺便提升一下质量。最重要的是，我想免费分享。&lt;/p&gt;&#xA;&lt;h3 id=&#34;目标&#34;&gt;目标 &lt;a href=&#34;#%e7%9b%ae%e6%a0%87&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;线性规划这个内容，不只是数学系有。在其他专业，比如经济管理，机械制造，自动化，计算机都有讲。只不过侧重点各有不同。这也间接证明了，这个课程的实用性。&lt;/p&gt;&#xA;&lt;p&gt;从这个实用性出发。我想实现下面两个目标。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;提升工程能力&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果你是数学背景，或者说工程经验有欠缺。我希望这个教程能帮你提升工程能力。&#xA;这里主要讲相关算法的实现。比如说，我们从0到1实现一个线性规划的求解器。当然，这是实验性质的，离真正的产品还很遥远。但这个实现过程，会让我们看到工程化的思想。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;降低学习门槛&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;线性规划是很有用的。但是学习和使用门槛不低。如果能降低它的使用门槛，让更多的人能掌握这个技术，那么它的价值会更大。基本思路就是从例子出发，让非数学背景的人，也能理解背后的思想，并且能够顺利上手。&lt;/p&gt;&#xA;&lt;p&gt;当然，要实现这两个目标并不容易。我打算慢慢来，通过持续迭代，去接近这两个目标。&lt;/p&gt;&#xA;&lt;h3 id=&#34;前提&#34;&gt;前提 &lt;a href=&#34;#%e5%89%8d%e6%8f%90&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;如果你想学习这个教程，最好是具备这些前提知识。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;线性代数&lt;/strong&gt; 了解矩阵和向量相关的计算，比如矩阵乘法，求逆，求秩等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;编程能力&lt;/strong&gt; 了解Python编程，了解面向对象编程的思想。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;原则&#34;&gt;原则 &lt;a href=&#34;#%e5%8e%9f%e5%88%99&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;下面是关于写作的原则，主是为了约束我自己。我认为遵循这些原则，对提升文章的可读性和实用性是有帮助的。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;保持简单。语言尽量简单，尽量口语化，让人读起来轻松。但是，保持简单的同时，会损失一些严谨性。我觉得这个可以接受，因为这是讲实践，而不是做理论证明。&lt;/li&gt;&#xA;&lt;li&gt;独立性。各章节的内容要尽量独立，不要交叉引用。这样做的好处是，节约阅读时间。假如你要看后面的章节，跳过去直接看就行，而不需要从头开始。当然，完全不引用，是做不到的。有一些基础知识，是要提前掌握的。&lt;/li&gt;&#xA;&lt;li&gt;有例子。所有的知识点都要有具体的例子，不能空讲理论。如果写不清楚，那就不写。但是要注意，例子的作用是帮助理解，代替不了证明。&lt;/li&gt;&#xA;&lt;li&gt;能验证。用代码去实现相关算法，要有测试用例。不但要保证代码的质量，还要保证代码与教程的一致性。&lt;/li&gt;&#xA;&lt;li&gt;用中文。本文档的第一语言是中文。有些地方可能会标注英文，是为了方便检索。但是有例外，代码或伪代码会用英文。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;交流&#34;&gt;交流 &lt;a href=&#34;#%e4%ba%a4%e6%b5%81&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;欢迎交流，提意见或建议。&lt;/p&gt;</description>
    </item>
    <item>
      <title>算法示例</title>
      <link>//localhost:1313/docs/simplex-algorithm/example/</link>
      <pubDate>Thu, 27 Mar 2025 13:47:58 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/example/</guid>
      <description></description>
    </item>
    <item>
      <title>处理退化</title>
      <link>//localhost:1313/docs/simplex-algorithm/implement/simplex-degeneracy/</link>
      <pubDate>Thu, 27 Mar 2025 13:55:23 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/implement/simplex-degeneracy/</guid>
      <description></description>
    </item>
    <item>
      <title>处理退化</title>
      <link>//localhost:1313/docs/simplex-algorithm/degeneracy/</link>
      <pubDate>Thu, 27 Mar 2025 13:42:05 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/degeneracy/</guid>
      <description></description>
    </item>
    <item>
      <title>可行区域</title>
      <link>//localhost:1313/docs/basics/feasible-region/</link>
      <pubDate>Mon, 24 Mar 2025 17:21:06 +0800</pubDate>
      <guid>//localhost:1313/docs/basics/feasible-region/</guid>
      <description>&lt;p&gt;从一个例子开始。&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;\begin{aligned}&#xA;\max~ &amp;amp; 5x_1 &amp;#43; 3x_2\\&#xA;\text{s.t. }&amp;amp; x_1 &amp;#43; 2x_2 \leq 8\\&#xA;&amp;amp; 3x_1 &amp;#43; 4x_2 \leq 20\\&#xA;&amp;amp; x_1\geq 0, x_2\geq 0&#xA;\end{aligned}&#xA;$$&#xA;  &lt;/div&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来看它的约束条件。&lt;/p&gt;&#xA;&lt;p&gt;把 $x_1,x_2$ 看成平面的两条坐标轴，那么 $x_1\geq 0$ 和 $x_2\geq 0$ 就表示下面的区域。&lt;/p&gt;&#xA;&lt;figure class=&#34;text-center&#34;&gt;&lt;img src=&#34;//localhost:1313/docs/basics/feasible-region/x1x2.png&#34; width=&#34;400px&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;第一个不等式 $x_1 + 2x_2 \leq 8$，它表示直线 $x_1+2x_2=8$ 的下半边部分。把它跟 $x_1\geq 0$ 和 $x_2\geq 0$ 取交集，如下图所示。&lt;/p&gt;&#xA;&lt;figure class=&#34;text-center&#34;&gt;&lt;img src=&#34;//localhost:1313/docs/basics/feasible-region/line1.png&#34; width=&#34;400px&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;第二个约束条件 $3x_1 + 4x_2 \leq 20$，它表示直线  $3x_1 + 4x_2 \leq 20$ 的左半边部分。再把它跟前面的区域取交集。&lt;/p&gt;&#xA;&lt;figure class=&#34;text-center&#34;&gt;&lt;img src=&#34;//localhost:1313/docs/basics/feasible-region/line2.png&#34; width=&#34;400px&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;可行域&#34;&gt;可行域 &lt;a href=&#34;#%e5%8f%af%e8%a1%8c%e5%9f%9f&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;所有约束条件取交集，得到的点 $x=(x_1,x_2)$ 的集合，称为&lt;strong&gt;可行区域  (Feasible Region)&lt;/strong&gt;，或者叫&lt;strong&gt;可行域&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>处理起点</title>
      <link>//localhost:1313/docs/simplex-algorithm/implement/simplex-two-phase/</link>
      <pubDate>Thu, 27 Mar 2025 13:58:44 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/implement/simplex-two-phase/</guid>
      <description></description>
    </item>
    <item>
      <title>基本可行解</title>
      <link>//localhost:1313/docs/basics/basic-feasible-solution/</link>
      <pubDate>Tue, 25 Mar 2025 13:30:41 +0800</pubDate>
      <guid>//localhost:1313/docs/basics/basic-feasible-solution/</guid>
      <description>&lt;p&gt;线性规划的约束条件定义了可行区域。如下图所示，可行区域是连续的，其中可行解有无穷多个。那么最优解适否存在。如果存在，如何找到它呢。因此，有必要研究一下最优解的性质。&lt;/p&gt;&#xA;&lt;figure class=&#34;text-center&#34;&gt;&lt;img src=&#34;//localhost:1313/docs/basics/basic-feasible-solution/vertex.png&#34; width=&#34;300px&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;可以证明如下结论。&lt;/p&gt;&#xA;&#xA;&lt;div class=&#34;alert alert-info d-flex&#34; role=&#34;alert&#34;&gt;&#xA;  &lt;div class=&#34;flex-shrink-1 alert-icon&#34;&gt;&#xA;  &#xA;  &lt;span class=&#34;material-icons size-20 me-2&#34;&gt;&#xA;  info&#xA;  &lt;/span&gt;&lt;/div&gt;&#xA;  &#xA;  &lt;div class=&#34;w-100&#34;&gt;&lt;strong&gt;定理&lt;/strong&gt; 最优解是可行区域的一个顶点。&lt;/div&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;注意，顶点的数量是有限的。这样一来，最优解一定存在。可以枚举所有顶点，找到目标函数值最优的顶点。当然，枚举的效率太低，需要设计更好的算法。&lt;/p&gt;&#xA;&lt;p&gt;但是，有一个概念没讲清楚。那就是，什么是顶点。从几何视角来看，顶点不难理解。接下里，需要从代数角度进行定义，这样才方便计算。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标准形&#34;&gt;标准形 &lt;a href=&#34;#%e6%a0%87%e5%87%86%e5%bd%a2&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;考虑线性规划的标准形式：&lt;/p&gt;&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;\begin{aligned}&#xA;\min~ &amp;amp; c^T x\\ &#xA;\text{s.t.}~ &amp;amp; Ax=b\\&#xA;&amp;amp; x\geq 0&#xA;\end{aligned}&#xA;$$&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;其中 $c, x \in \mathbb{R}^n$，$A\in\mathbb{R}^{m\times n}$，$b\in\mathbb{R}^m \geq \mathbf{0}$，$n\geq m$。&lt;/p&gt;&#xA;&lt;h3 id=&#34;基矩阵&#34;&gt;基矩阵 &lt;a href=&#34;#%e5%9f%ba%e7%9f%a9%e9%98%b5&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;注意 $A$ 是一个 $m$ 行 $n$ 列的矩阵，可以把它看成 $n$ 个 $m$ 维的列向量。&#xA;$$&#xA;A = [a_1, a_2, &amp;hellip;, a_n]&#xA;$$&#xA;其中 $a_j \in \mathbb{R}^m$，$j=1,2,&amp;hellip;n$。&lt;/p&gt;&#xA;&lt;p&gt;接下来把 $A$ 拆成两个部分：&#xA;$$&#xA;A = [B \quad N]&#xA;$$&#xA;其中 $B$ 包含前 $m$ 列，因此 $B$ 是一个方阵，即 $B\in \mathbb{R}^{m\times m}$；而 $N$ 包含剩下的 $n-m$ 列，因此 $N \in \mathbb{R}^{m \times (n-m)}$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>处理起点</title>
      <link>//localhost:1313/docs/simplex-algorithm/start-vertex/</link>
      <pubDate>Thu, 27 Mar 2025 13:48:18 +0800</pubDate>
      <guid>//localhost:1313/docs/simplex-algorithm/start-vertex/</guid>
      <description></description>
    </item>
    <item>
      <title>什么是线性规划</title>
      <link>//localhost:1313/docs/start/what-is-lp/</link>
      <pubDate>Fri, 21 Mar 2025 19:47:58 +0800</pubDate>
      <guid>//localhost:1313/docs/start/what-is-lp/</guid>
      <description>&lt;p&gt;线性规划的英文是 Linear Programming。注意，Programming 不是编程的意思，它指的是一类优化问题。从字面翻译，Linear Programming 就是一种线性的优化问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;线性规划&#34;&gt;线性规划 &lt;a href=&#34;#%e7%ba%bf%e6%80%a7%e8%a7%84%e5%88%92&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;&lt;i class=&#34;material-icons align-middle&#34;&gt;link&lt;/i&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我们看一个例子。&#xA;&#xA;  &lt;div class=&#34;equation leqno&#34; &gt;$$&#xA;\begin{aligned}&#xA;\max~ &amp;amp; 7x_1 &amp;#43; 6x_2 \\&#xA;\text{s.t. }  &amp;amp; 3x_1 &amp;#43; x_2 \leq 120 \\&#xA;&amp;amp; x_1 &amp;#43; 2x_2 \leq 160 \\&#xA;&amp;amp; x_1 \leq 35\\&#xA;\end{aligned}&#xA;$$&#xA;  &lt;/div&gt;&lt;/p&gt;&#xA;&lt;p&gt;第一行的表达式 $7x_1 + 6x_2$ 称为&lt;strong&gt;目标函数&lt;/strong&gt;，它前面那个 &lt;code&gt;max&lt;/code&gt; 是 &lt;code&gt;maximize&lt;/code&gt; 的缩写，代表优化方向。即，找到满足条件的 $x_1, x_2$ 使得这个目标函数值最大。接下来的三行公式描述 $x_1, x_2$ 要满足的条件，其中 &lt;code&gt;s.t.&lt;/code&gt; 是 &lt;code&gt;subject to&lt;/code&gt; 的缩写。&lt;/p&gt;&#xA;&lt;p&gt;以第一个条件为例，如果 $x_1=40, x_2=0$, 它满足 $3x_1 + x_2 \leq 120$ 这个条件。但是，它不满足第三个条件 $x_1\leq 35$。因此 $x_1=40, x_2=0$ 不符合要求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何写线性规划</title>
      <link>//localhost:1313/docs/modeling/write-linear-program/</link>
      <pubDate>Sat, 22 Mar 2025 17:33:08 +0800</pubDate>
      <guid>//localhost:1313/docs/modeling/write-linear-program/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>分支定界法</title>
      <link>//localhost:1313/docs/integer-programming/branch-and-bound/</link>
      <pubDate>Sat, 22 Mar 2025 17:12:18 +0800</pubDate>
      <guid>//localhost:1313/docs/integer-programming/branch-and-bound/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>列生成</title>
      <link>//localhost:1313/docs/decomposition/column-generation/</link>
      <pubDate>Sat, 22 Mar 2025 17:07:49 +0800</pubDate>
      <guid>//localhost:1313/docs/decomposition/column-generation/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>版权声明</title>
      <link>//localhost:1313/docs/start/copyright/</link>
      <pubDate>Sat, 22 Mar 2025 10:55:26 +0800</pubDate>
      <guid>//localhost:1313/docs/start/copyright/</guid>
      <description>&lt;div class=&#34;alert alert-info d-flex&#34; role=&#34;alert&#34;&gt;&#xA;  &lt;div class=&#34;flex-shrink-1 alert-icon&#34;&gt;&#xA;  &#xA;  &lt;span class=&#34;material-icons size-20 me-2&#34;&gt;&#xA;  info&#xA;  &lt;/span&gt;&lt;/div&gt;&#xA;  &#xA;  &lt;div class=&#34;w-100&#34;&gt;&lt;strong&gt;声明&lt;/strong&gt; 本网站所有内容（包括文档和代码）版权归作者所有。&lt;/div&gt;&#xA;  &lt;/div&gt;&#xA;&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有内容对个人免费开放；&lt;/li&gt;&#xA;&lt;li&gt;允许个人对内容进行复制、修改和分发；&lt;/li&gt;&#xA;&lt;li&gt;不允许直接出售相关资料；&lt;/li&gt;&#xA;&lt;li&gt;允许在社交媒体中引用本网站的内容（期待注明出处）；&lt;/li&gt;&#xA;&lt;li&gt;允许在出版物中引用本网站的内容（期待注明出处）；&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>如何写对偶问题</title>
      <link>//localhost:1313/docs/modeling/write-dual/</link>
      <pubDate>Sat, 22 Mar 2025 17:33:14 +0800</pubDate>
      <guid>//localhost:1313/docs/modeling/write-dual/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>割平面法</title>
      <link>//localhost:1313/docs/integer-programming/cutting-plane/</link>
      <pubDate>Sat, 22 Mar 2025 17:12:29 +0800</pubDate>
      <guid>//localhost:1313/docs/integer-programming/cutting-plane/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>行生成</title>
      <link>//localhost:1313/docs/decomposition/row-generation/</link>
      <pubDate>Sat, 22 Mar 2025 17:08:12 +0800</pubDate>
      <guid>//localhost:1313/docs/decomposition/row-generation/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>线性化技巧</title>
      <link>//localhost:1313/docs/modeling/linearize/</link>
      <pubDate>Sat, 22 Mar 2025 17:39:17 +0800</pubDate>
      <guid>//localhost:1313/docs/modeling/linearize/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
    <item>
      <title>Benders分解</title>
      <link>//localhost:1313/docs/decomposition/benders/</link>
      <pubDate>Sat, 22 Mar 2025 17:08:24 +0800</pubDate>
      <guid>//localhost:1313/docs/decomposition/benders/</guid>
      <description>&lt;p&gt;tba&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
